import tkinter as tk
from tkinter import ttk, messagebox
from datetime import datetime, timedelta, timezone
from skyfield.api import load, EarthSatellite, wgs84
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.dates import MinuteLocator
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
import pandas as pd
import sys
import itur as itu
import astropy.units as u
import warnings 
from scipy.interpolate import interp1d

# Suppress RuntimeWarnings for cleaner output, especially from numerical operations
warnings.filterwarnings("ignore", category=RuntimeWarning)

# --- Constants and Configuration ---
# Define ground stations as a constant dictionary
GROUND_STATIONS = {
    "Darmstadt": (49.8700, 8.6500, 144),
    "Lannion": (48.7333, -3.4542, 31),
    "Maspalomas": (27.7614, -15.5865, 250),
    "Athens": (37.9838, 23.7275, 70),
    "Kangerlussuaq": (67.0121, -50.7078, 50),
    "Svalbard": (78.2232, 15.6267, 10)
}

# Antenna pattern data as constants
ANTENNA_PATTERN_ANGLES = np.array([
    -65, -55, -45, -35, -25, -15, -5, 0, 5, 15, 25, 35, 45, 55, 65
])
ANTENNA_PATTERN_GAINS = np.array([
    0.5, 1.2, 2.3, 3.5, 4.3, 5.0, 5.5, 5.6, 5.5, 5.0, 4.3, 3.5, 2.3, 1.2, 0.5
])
# Interpolation function for antenna pattern
PATTERN_INTERP = interp1d(ANTENNA_PATTERN_ANGLES, ANTENNA_PATTERN_GAINS,
                          kind='linear', fill_value=0.0, bounds_error=False)
MAX_ANTENNA_GAIN = 5.6 # Extracted max gain from antenna_pattern_gains

# Global variables (used sparingly and with clear purpose)
contact_windows = [] # Stores validated contact windows
df_all = pd.DataFrame() # Stores all computed pass data
analysis_needs_refresh = True # Flag per indicare se l'analisi completa necessita di essere aggiornata

# --- Helper Functions ---
def antenna_pattern(angle_deg):
    """Calculates antenna pointing loss for a given off-boresight angle."""
    gain_at_angle = PATTERN_INTERP(angle_deg)
    loss = MAX_ANTENNA_GAIN - gain_at_angle
    return max(loss, 0.0)

def calculate_link_budget_parameters(
    t_sky, sat, gs, freq, p, r001, d_gs, alt_gs, eirp_sat, gt_gs,
    demod_loss, bitrate, overhead, cisat_lin, other_att
):
    """
    Calculates various link budget parameters for a single time step.
    Returns a dictionary of calculated values.
    """
    diff = sat - gs
    topocentric = diff.at(t_sky)
    alt, az, dist = topocentric.altaz()
    elev = alt.degrees
    visible = elev >= 5 # Consider visible if elevation is 5 degrees or more

    # Initialize all parameters to None (or appropriate NaN for numerical)
    slant_range_km = path_loss = atm_att = rain_att = scint_att = gas_att = None
    rx_power = cn0 = ebno = off_boresight_angle = pointing_loss = None

    if visible:
        slant_range_km = topocentric.distance().to(u.km).value
        # Friis transmission equation in dB
        path_loss = 20 * np.log10(slant_range_km) + 20 * np.log10(freq.to(u.GHz).value) + 92.45

        try:
            Ag, Ac, Ar, As, A_tot = itu.atmospheric_attenuation_slant_path(
            gs.latitude.degrees, gs.longitude.degrees, freq.to(u.GHz).value,
            elev, p, d_gs,
            hs=alt_gs, R001=r001,
            return_contributions=True,
            include_gas=True,
            include_rain=True,
            include_clouds=True,
            include_scintillation=True
            )
            atm_att = float(A_tot.value if hasattr(A_tot, 'value') else A_tot)
            
            # Somma tutte le attenuazioni per ottenere l'attenuazione atmosferica totale

        except Exception as e: # Catch the exception and print it
            print(f"Error calculating atmospheric attenuation in calculate_link_budget_parameters: {e}", file=sys.stderr)
            print(f"  Inputs for error: lat={gs.latitude.degrees}, lon={gs.longitude.degrees}, freq_GHz={freq.to(u.GHz).value}, elev={elev}, P={p}, R001={r001}, D={d_gs}, h_s={alt_gs}", file=sys.stderr)
            atm_att = 0.0

        # Calculate pointing loss
        r_sat = sat.at(t_sky).position.km
        r_gs = gs.at(t_sky).position.km
        bore = -r_sat / np.linalg.norm(r_sat)
        to_gs = (r_gs - r_sat) / np.linalg.norm(r_gs - r_sat)
        angle_rad = np.arccos(np.clip(np.dot(bore, to_gs), -1.0, 1.0))
        off_boresight_angle = np.degrees(angle_rad)
        pointing_loss = antenna_pattern(off_boresight_angle)

        # Calculate received power and C/N0
        rx_power = eirp_sat - path_loss - atm_att - other_att - pointing_loss
        cno_db = rx_power + gt_gs + 228.6 - demod_loss # Boltzmann constant k = -228.6 dBW/Hz/K

        if cisat_lin is not None:
            cno_lin = 10**(cno_db / 10.0)
            cni_lin = 1.0 / (1.0 / cno_lin + 1.0 / cisat_lin)
            cn0 = 10.0 * np.log10(cni_lin)
        else:
            cn0 = cno_db

        # Calculate Eb/N0
        if cn0 is not None and bitrate > 0 and overhead > 0:
            ebno = cn0 - 10 * np.log10(bitrate / overhead)
        else:
            ebno = np.nan

        # Calculate SNR
        # Calculate SNR (uso il valore numerico bitrate/overhead, non la StringVar)
        #if cn0 is not None and bitrate > 0 and rolloff >= 0:
        #    channel_bw_hz = bitrate * (1 + rolloff)
        #à    snr = cn0 - 10 * np.log10(channel_bw_hz)
#        else:
#            snr = np.nan
    return {
        "Time (UTC)": t_sky.utc_datetime(), # This is already UTC-aware
        "Elevation (°)": elev,
        "Slant Range (km)": slant_range_km,
        "Path Loss (dB)": path_loss,
        #"Other Attenuations (dB)": other_att,
        "Pointing Loss (dB)": pointing_loss,
        "Off Boresight Angle (°)": off_boresight_angle,
        "Rx Power (dBW)": rx_power,
        "C/(No+Io) (dBHz)": cn0,
#        "SNR (dB)": snr,
        "Eb/No (dB)": ebno,
        "Visible": "YES" if visible else "NO"
    }

# Funzione per impostare lo stato di analisi "scaduta"
def set_analysis_stale():
    """
    Sets a flag indicating that the analysis needs to be refreshed and
    updates the 'Start/Refresh Analysis' button's appearance.
    """
    global analysis_needs_refresh
    if not analysis_needs_refresh: # Cambia lo stato solo se era "aggiornato"
        analysis_needs_refresh = True
        start_refresh_button.config(style="Red.TButton") # Imposta lo stile del pulsante a "Rosso"
        recalc_button.config(state='disabled') # Disabilita "Recalculate Link Budget" se l'analisi completa è scaduta
        clear_plot_and_table() # Pulisci i risultati precedenti per chiarezza
        contact_listbox.delete(0, tk.END) # Pulisci la lista dei contatti


# --- Main Analysis Function ---
def run_analysis():
    """
    Performs the satellite pass and link budget analysis based on user inputs.
    Updates global dataframes and displays results.
    """
    global contact_windows, df_all, analysis_needs_refresh # Aggiungi la variabile globale

    # --- Input Validation and Parsing ---
    tle1 = tle1_entry.get().strip()
    tle2 = tle2_entry.get().strip()
    gs_name = gs_var.get()
    date_str = date_entry.get().strip()

    if not all([tle1, tle2, gs_name, date_str]):
        messagebox.showerror("Error", "All TLE, Ground Station, and Date fields must be filled.")
        return

    try:
        # Make obs_date timezone-aware (UTC)
        obs_date = datetime.strptime(date_str, "%Y-%m-%d").replace(tzinfo=timezone.utc)
    except ValueError:
        messagebox.showerror("Error", "Invalid date format. Please useYYYY-MM-DD.")
        return

    try:
        # Parse numerical inputs, providing sensible defaults or error handling
        freq = float(freq_entry.get()) * u.GHz
        link_availability = float(LA_entry.get())
        p = 100.0 - link_availability # Convert link availability to percentage exceedance
        r001 = float(r001_entry.get())
        d_gs = float(d_gs_entry.get())
        other_att = float(other_att_entry.get() or 0.0) # Use 0.0 if empty
        eirp_sat = float(eirp_sat_entry.get())
        gt_gs = float(gt_gs_entry.get())
        cisat_db = float(CIo_entry.get()) if CIo_entry.get().strip() else None
        cisat_lin = 10**(cisat_db / 10.0) if cisat_db is not None else None
        bitrate = float(bitrate_entry.get()) * 1e6
        rolloff = float(rolloff_entry.get()) # Rolloff is not used in link budget, only for derived baseband
        demod_loss = float(demod_loss_entry.get())
        overhead = float(overhead_entry.get())

        if bitrate <= 0 or overhead <= 0:
            messagebox.showwarning("Warning", "Bit Rate and Overhead must be positive values for Eb/No calculation.")

    except ValueError as e:
        messagebox.showerror("Input Error", f"Invalid numerical input: {e}. Please ensure all numerical fields are correctly filled.")
        return

    # --- Skyfield Setup ---
    lat_gs, lon_gs, alt_gs_m = GROUND_STATIONS[gs_name]
    alt_gs_km = alt_gs_m / 1000.0 # Skyfield uses km for elevation for some functions

    ts = load.timescale()
    try:
        sat = EarthSatellite(tle1, tle2, 'SAT', ts)
    except Exception as e:
        messagebox.showerror("TLE Error", f"Invalid TLE data: {e}. Please check the TLE lines.")
        return
    gs = wgs84.latlon(lat_gs, lon_gs, elevation_m=alt_gs_m)

    # --- Time Series Generation (for 24 hours) ---
    # Make start_time timezone-aware (UTC)
    start_time = datetime(obs_date.year, obs_date.month, obs_date.day, 0, 0, 0, tzinfo=timezone.utc)
    # Generate times for 24 hours at 30-second intervals
    times = [start_time + timedelta(seconds=30 * i) for i in range(2880)]
    sky_times = ts.utc([t.year for t in times], [t.month for t in times],
                       [t.day for t in times], [t.hour for t in times],
                       [t.minute for t in times], [t.second for t in times])

    # --- Batch Calculation for Skyfield ---
    # Calculate topocentric positions for all times at once for efficiency
    diff_at_all_times = (sat - gs).at(sky_times)
    altitudes, azimuths, distances = diff_at_all_times.altaz()

    results_list = []
    contact_windows.clear() # Clear previous contact windows
    in_contact = False
    contact_start_time = None

    for i, t_utc_dt in enumerate(times):
        elev = altitudes.degrees[i]
        t_sky = sky_times[i] # Current Skyfield time object

        # Calculate link budget parameters for the current time step
        params = calculate_link_budget_parameters(
            t_sky, sat, gs, freq, p, r001, d_gs, alt_gs_km, eirp_sat, gt_gs,
            demod_loss, bitrate, overhead, cisat_lin, other_att
        )

        # Round numerical values before appending to results
        for key in ["Elevation (°)", "Slant Range (km)", "Path Loss (dB)",
                    "Pointing Loss (dB)", "Off Boresight Angle (°)",
                    "Rx Power (dBW)", "C/(No+Io) (dBHz)", "Eb/No (dB)"]:
            if params[key] is not None:
                params[key] = round(params[key], 2)

        results_list.append(params)

        # Detect contact windows based on elevation > 5 degrees
        is_visible_now = elev >= 5
        if is_visible_now and not in_contact:
            contact_start_time = t_utc_dt # This is already UTC-aware
            in_contact = True
        elif not is_visible_now and in_contact:
            contact_end_time = t_utc_dt # This is already UTC-aware
            contact_windows.append((contact_start_time, contact_end_time))
            in_contact = False

    # Handle the case where contact extends to the end of the analysis period
    if in_contact:
        contact_windows.append((contact_start_time, times[-1]))

    df_all = pd.DataFrame(results_list)

    # Update total atmospheric attenuation label
    try:
        Ag, Ac, Ar, As, A_tot = itu.atmospheric_attenuation_slant_path(
        gs.latitude.degrees, gs.longitude.degrees, freq.to(u.GHz).value,
        5, p, d_gs,
        hs=alt_gs_km, R001=r001,
        return_contributions=True,
        include_gas=True,
        include_rain=True,
        include_clouds=True,
        include_scintillation=True
        )
        atm_val = float(A_tot.value if hasattr(A_tot, 'value') else A_tot)

        atm_label_var.set(f"Atmospheric Att (dB) @ 5° El: {atm_val:.2f}")
    except Exception as e: # Catch the exception and print it for the label update
        print(f"Error calculating atmospheric attenuation for label: {e}", file=sys.stderr)
        print(f"  Inputs for error (label): lat={lat_gs}, lon={lon_gs}, freq_GHz={freq.to(u.GHz).value}, elev=5, P={p}, R001={r001}, D={d_gs}, h_s={alt_gs_km}", file=sys.stderr)
        atm_label_var.set("Atmospheric Attenuation (dB) @ 5° El: N/A")

    # Display contact windows and select the first one if available
    display_contacts(contact_windows)
    if contact_windows:
        contact_listbox.selection_set(0)
        on_contact_select(None) # Automatically plot the first contact
    else:
        clear_plot_and_table() # Pulisci plot e tabella se non ci sono contatti

    # Aggiorna lo stato e il colore del pulsante
    analysis_needs_refresh = False
    start_refresh_button.config(style="TButton") # Reimposta lo stile normale del pulsante
    recalc_button.config(state='!disabled') # Abilita il pulsante di ricalcolo

# --- Recalculate Link Budget Function (Refactored) ---
def recalculate_link_budget():
    """
    Recalculates link budget parameters for existing data based on new input
    parameters without re-running the satellite pass analysis.
    """
    global df_all

    if df_all.empty:
        messagebox.showwarning("Warning", "Please generate passes first.")
        return
    
    # Se l'analisi di base è scaduta, non permettere il ricalcolo del link budget.
    if analysis_needs_refresh:
        messagebox.showwarning("Warning", "Please click 'Start/Refresh Analysis' first to update the pass data.")
        return

    try:
        # Re-parse numerical inputs
        freq = float(freq_entry.get()) * u.GHz
        link_availability = float(LA_entry.get())
        p = 100.0 - link_availability
        r001 = float(r001_entry.get())
        d_gs = float(d_gs_entry.get())
        other_att = float(other_att_entry.get() or 0.0)
        eirp_sat = float(eirp_sat_entry.get())
        gt_gs = float(gt_gs_entry.get())
        cisat_db = float(CIo_entry.get()) if CIo_entry.get().strip() else None
        cisat_lin = 10**(cisat_db / 10.0) if cisat_db is not None else None
        bitrate = float(bitrate_entry.get()) * 1e6
        demod_loss = float(demod_loss_entry.get())
        overhead = float(overhead_entry.get())

        if bitrate <= 0 or overhead <= 0:
            messagebox.showwarning("Warning", "Bit Rate and Overhead must be positive values for Eb/No calculation.")

    except ValueError as e:
        messagebox.showerror("Input Error", f"Invalid numerical input: {e}. Please ensure all numerical fields are correctly filled.")
        return

    gs_name = gs_var.get()
    lat_gs, lon_gs, alt_gs_m = GROUND_STATIONS[gs_name]
    alt_gs_km = alt_gs_m / 1000.0

    ts = load.timescale()
    tle1 = tle1_entry.get().strip()
    tle2 = tle2_entry.get().strip()
    try:
        sat = EarthSatellite(tle1, tle2, 'SAT', ts)
    except Exception as e:
        messagebox.showerror("TLE Error", f"Invalid TLE data: {e}. Please check the TLE lines.")
        return
    gs = wgs84.latlon(lat_gs, lon_gs, elevation_m=alt_gs_m)

    updated_results = []
    for index, row in df_all.iterrows():
        t_utc_dt = row["Time (UTC)"]
        # Ensure t_sky is created correctly from the UTC-aware datetime
        t_sky = ts.utc(t_utc_dt.year, t_utc_dt.month, t_utc_dt.day,
                       t_utc_dt.hour, t_utc_dt.minute, t_utc_dt.second)

        params = calculate_link_budget_parameters(
            t_sky, sat, gs, freq, p, r001, d_gs, alt_gs_km, eirp_sat, gt_gs,
            demod_loss, bitrate, overhead, cisat_lin, other_att
        )

        # Round numerical values before appending to results
        for key in ["Elevation (°)", "Slant Range (km)", "Path Loss (dB)",
                    "Pointing Loss (dB)", "Off Boresight Angle (°)",
                    "Rx Power (dBW)", "C/(No+Io) (dBHz)", "Eb/No (dB)"]:
            if params[key] is not None:
                params[key] = round(params[key], 2)
        updated_results.append(params)

    df_all = pd.DataFrame(updated_results)

    # Update total atmospheric attenuation label
    
    try:
            Ag, Ac, Ar, As, A_tot = itu.atmospheric_attenuation_slant_path(
            gs.latitude.degrees, gs.longitude.degrees, freq.to(u.GHz).value,
            5, p, d_gs,
            hs=alt_gs_km, R001=r001,
            return_contributions=True,
            include_gas=True,
            include_rain=True,
            include_clouds=True,
            include_scintillation=True
            )
            atm_val = float(A_tot.value if hasattr(A_tot, 'value') else A_tot)
            atm_label_var.set(f"Atmospheric Att (dB): {atm_val:.2f}")

    except Exception as e: # Catch the exception and print it for the label update
        print(f"Error calculating atmospheric attenuation for label (recalculate): {e}", file=sys.stderr)
        print(f"  Inputs for error (label, recalculate): lat={lat_gs}, lon={lon_gs}, freq_GHz={freq.to(u.GHz).value}, elev=5, P={p}, R001={r001}, D={d_gs}, h_s={alt_gs_km}", file=sys.stderr)
        atm_label_var.set("Atmospheric Att (dB) @ 5° El: N/A")

    # Re-display the currently selected contact, or the first one if none selected
    selection = contact_listbox.curselection()
    if not selection and len(contact_windows) > 0:
        contact_listbox.selection_set(0)
        selection = (0,)

    if selection:
        on_contact_select(None)
    else:
        clear_plot_and_table() # Clear if no contacts remain after recalculation

# --- GUI Update Functions ---
def clear_plot_and_table():
    """Clears the matplotlib plot and the Treeview table."""
    for widget in plot_frame.winfo_children():
        widget.destroy()
    for widget in table_frame.winfo_children():
        widget.destroy()

def display_contacts(contacts):
    """
    Populates the contact listbox with filtered contact windows
    (elevation >= 5 degrees at some point).
    """
    contact_listbox.delete(0, tk.END)
    # Filter contacts to only include those that actually have data points
    filtered_contacts = []
    for start, end in contacts:
        # Ensure df_all has 'Time (UTC)' column as datetime for filtering
        if not df_all.empty:
            # The comparison here should now work because `start` and `end` are also UTC-aware
            mask = (df_all["Time (UTC)"] >= start) & (df_all["Time (UTC)"] <= end)
            df_segment = df_all[mask]
            # Check if any elevation in the segment is >= 5, or if the segment is not empty
            if not df_segment.empty and df_segment["Elevation (°)"].max() >= 5:
                filtered_contacts.append((start, end))
        # else: If df_all is empty, no contacts can be displayed - no action needed.

    # Update the global contact_windows with filtered contacts
    global contact_windows
    contact_windows = filtered_contacts

    for i, (start, end) in enumerate(contact_windows):
        contact_listbox.insert(tk.END, f"Contact {i+1}: {start.strftime('%H:%M:%S')} - {end.strftime('%H:%M:%S')}")

def on_contact_select(event):
    """
    Event handler for contact listbox selection. Plots and displays
    detailed link budget data for the selected contact window.
    """
    selection = contact_listbox.curselection()
    if not selection:
        clear_plot_and_table()
        return

    idx = selection[0]
    start, end = contact_windows[idx]

    # Filter df_all for the selected contact window
    mask = (df_all["Time (UTC)"] >= start) & (df_all["Time (UTC)"] <= end)
    df_pass = df_all[mask].copy()

    clear_plot_and_table()

    # --- Matplotlib Plotting ---
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4), gridspec_kw={'width_ratios': [1, 1]})

    # Get Tkinter background color and convert to a hex code Matplotlib can understand
    tk_bg_color = root.cget('bg')
    try:
        # Get the RGB values of the Tkinter color
        r, g, b = root.winfo_rgb(tk_bg_color)
        # Convert to 0-255 range and then to hex
        mpl_bg_color = f'#{r // 256:02x}{g // 256:02x}{b // 256:02x}'
    except tk.TclError:
        mpl_bg_color = '#F0F0F0' # A light grey fallback if system color fails

    fig.patch.set_facecolor(mpl_bg_color) # Match plot background to Tkinter window

    # Elevation Angle plot
    ax1.plot(df_pass["Time (UTC)"], df_pass["Elevation (°)"], label="Elevation (°)", color="tab:blue")
    ax1.set_ylabel("Elevation (°)", color="tab:blue")
    ax1.tick_params(axis='y', labelcolor="tab:blue")
    ax1.set_xlabel("Time (UTC)")
    
    # Apply 1-minute interval for ticks
    ax1.xaxis.set_major_locator(MinuteLocator(interval=1)) # Forzo ogni minuto
    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M')) # Formato ora:minuto
    
    ax1.grid(True, linestyle=':', alpha=0.7)
    ax1.set_title("Elevation Angle")
    fig.autofmt_xdate(rotation=30) # Rotate x-axis labels for readability

    # Eb/No and C/N0 plot with dual y-axes
    ax2_1 = ax2 # Primary Y-axis for Eb/No
    ax2_2 = ax2.twinx() # Secondary Y-axis for C/(N+Io)

    # Plot Eb/No
    ax2_1.plot(df_pass["Time (UTC)"], df_pass["Eb/No (dB)"], label="Eb/No (dB)", color="tab:red", linestyle='-')
    ax2_1.set_ylabel("Eb/No (dB)", color="tab:red")
    ax2_1.tick_params(axis='y', labelcolor="tab:red")

    # Plot C/(N+Io)
    ax2_2.plot(df_pass["Time (UTC)"], df_pass["C/(No+Io) (dBHz)"], label="C/(N+Io) (dBHz)", color="tab:green", linestyle='--')
    ax2_2.set_ylabel("C/(No+Io) (dBHz)", color="tab:green")
    ax2_2.tick_params(axis='y', labelcolor="tab:green")

    ax2.set_xlabel("Time (UTC)")
    
    # Apply 1-minute interval for ticks
    ax2.xaxis.set_major_locator(MinuteLocator(interval=1)) # Forzo ogni minuto
    ax2.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M')) # Formato ora:minuto
    
    ax2.grid(True, linestyle=':', alpha=0.7)
    ax2.set_title("Link Quality (Eb/No & C/(No+Io))")

    # Add legends to each axis (optional, or combine manually)
    lines, labels = ax2_1.get_legend_handles_labels()
    lines2, labels2 = ax2_2.get_legend_handles_labels()
    ax2.legend(lines + lines2, labels + labels2, loc='best')

    fig.tight_layout() # Adjust layout to prevent overlapping titles/labels

    # Embed plot in Tkinter
    canvas_plot_widget = FigureCanvasTkAgg(fig, master=plot_frame)
    canvas_plot_widget.draw()
    canvas_plot_widget.get_tk_widget().pack(side=tk.LEFT, anchor='nw', fill=tk.BOTH, expand=True)

    # --- Treeview Table ---
    # Define columns more explicitly and potentially adjust widths
    display_columns = ["Time (UTC)", "Elevation (°)", "Slant Range (km)", "Path Loss (dB)",
                         "Pointing Loss (dB)", "Off Boresight Angle (°)",
                       "Rx Power (dBW)", "C/(No+Io) (dBHz)","Eb/No (dB)"]

    # Recreate the table each time to ensure it's fresh
    table = ttk.Treeview(table_frame, columns=display_columns, show="headings")

    for col in display_columns:
        table.heading(col, text=col)
        # Set column widths based on content or a sensible default
        if col == "Time (UTC)":
            table.column(col, anchor="center", width=120)
        else:
            table.column(col, anchor="center", width=100) # Default width for data columns

    # Populate table with data
    for _, row in df_pass.iterrows():
        # Format Time (UTC) for display in the table
        formatted_time = row["Time (UTC)"].strftime('%Y-%m-%d %H:%M:%S')
        values = [formatted_time] + [row.get(col, "") for col in display_columns[1:]]
        table.insert("", "end", values=values)

    # Add scrollbars to the table if not already handled by the parent
    table_vscroll = ttk.Scrollbar(table_frame, orient=tk.VERTICAL, command=table.yview)
    table_hscroll = ttk.Scrollbar(table_frame, orient=tk.HORIZONTAL, command=table.xview)
    table.configure(yscrollcommand=table_vscroll.set, xscrollcommand=table_hscroll.set)

    table_vscroll.pack(side=tk.RIGHT, fill=tk.Y)
    table_hscroll.pack(side=tk.BOTTOM, fill=tk.X)
    table.pack(fill=tk.BOTH, expand=True) # Pack the table after scrollbars

def exit_app():
    """Exits the application gracefully."""
    plt.close('all') # Chiudi tutte le figure Matplotlib aperte
    root.quit()      # Termina il mainloop di Tkinter
    root.destroy()   # Distrugge la finestra principale
    sys.exit()       # Forza l'uscita dal processo Python

def show_antenna_pattern():
    """Displays a popup window with the antenna gain pattern plot."""
    popup = tk.Toplevel(root)
    popup.title("Antenna Pattern")
    popup.geometry("600x400")

    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(ANTENNA_PATTERN_ANGLES, ANTENNA_PATTERN_GAINS, marker='o', linestyle='-')
    ax.set_xlabel("Angle (degrees)")
    ax.set_ylabel("Gain (dB)")
    ax.set_title("Antenna Gain Pattern")
    ax.grid(True, linestyle=':', alpha=0.7)

    canvas_popup = FigureCanvasTkAgg(fig, master=popup)
    canvas_popup.draw()
    canvas_popup.get_tk_widget().pack(side=tk.LEFT, anchor='nw', fill=tk.BOTH, expand=True)

def update_link_budget_derived(*args):
    """
    Calculates and updates derived baseband parameters (Info Bit Rate, Channel BW).
    """
    try:
        bit_rate_mbps = float(bitrate_entry.get())
        roll_off = float(rolloff_entry.get())
        overhead = float(overhead_entry.get())

        info_bit_rate_mbps = bit_rate_mbps / overhead if overhead != 0 else 0
        channel_bw_mhz = bit_rate_mbps * (1 + roll_off) / 2

        info_bitrate_var.set(f"Info Bit Rate [Mbps]: {info_bit_rate_mbps:.3f}")
        channel_bw_var.set(f"Channel BW [MHz] (QPSK): {channel_bw_mhz:.3f}")
    except ValueError: # Catch cases where inputs are not valid numbers
        info_bitrate_var.set("Info Bit Rate [Mbps]: N/A")
        channel_bw_var.set("Channel BW [MHz] (QPSK): N/A")

# --- GUI Setup ---
def setup_gui():
    """Initializes and lays out the Tkinter GUI elements."""
    global root, tle1_entry, tle2_entry, date_entry, gs_var, freq_entry, \
           LA_entry, r001_entry, d_gs_entry, other_att_entry, eirp_sat_entry, \
           gt_gs_entry, CIo_entry, bitrate_entry, rolloff_entry, demod_loss_entry, \
           overhead_entry, atm_label_var, info_bitrate_var, channel_bw_var, \
           recalc_button, contact_listbox, plot_frame, table_frame, start_refresh_button

    root = tk.Tk()
    root.title("Satellite Link Budget Tool")
    root.geometry("1200x950") # Slightly larger default window

    # Configure a modern theme for ttk widgets
    style = ttk.Style()
    style.theme_use('clam') # or 'alt', 'default', 'vista', 'xpnative'

    # Definisci uno stile personalizzato per il pulsante rosso
    style.configure("Red.TButton", background="red", foreground="white", font=('TkDefaultFont', 10, 'bold'))
    # Usa map per gestire i diversi stati (normale, attivo) del background
    style.map("Red.TButton",
              background=[('active', 'darkred'), ('!active', 'red')],
              foreground=[('active', 'white'), ('!active', 'white')])

    # Make the root window's single column and row expand
    root.grid_rowconfigure(0, weight=1)
    root.grid_columnconfigure(0, weight=1)

    # Main scrollable area
    canvas_frame = ttk.Frame(root)
    canvas_frame.grid(row=0, column=0, sticky="nsew")
    canvas_frame.grid_rowconfigure(0, weight=1)
    canvas_frame.grid_columnconfigure(0, weight=1)


    canvas = tk.Canvas(canvas_frame)
    canvas.grid(row=0, column=0, sticky="nsew")

    scrollbar_y = ttk.Scrollbar(canvas_frame, orient="vertical", command=canvas.yview)
    scrollbar_x = ttk.Scrollbar(canvas_frame, orient="horizontal", command=canvas.xview)
    scrollbar_y.grid(row=0, column=1, sticky="ns")
    scrollbar_x.grid(row=1, column=0, sticky="ew")

    canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

    # Bind mousewheel events for scrolling
    def _on_mousewheel(event):
        # On Windows/Linux, event.delta is typically +/- 120 per scroll "notch"
        # On Mac, event.delta is typically +/- 1 for smooth scrolling
        if sys.platform == 'darwin':
            canvas.yview_scroll(-1 * event.delta, "units")
        else:
            canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    def _on_shift_mousewheel(event):
        if sys.platform == 'darwin':
            canvas.xview_scroll(-1 * event.delta, "units")
        else:
            canvas.xview_scroll(int(-1 * (event.delta / 120)), "units")
            
    # Apply bindings using the correct event name for each platform
    if sys.platform == 'darwin':
        canvas.bind_all("<Mousewheel>", _on_mousewheel) # 'Mousewheel' for Mac
        canvas.bind_all("<Shift-Mousewheel>", _on_shift_mousewheel) # 'Mousewheel' for Mac
    else:
        # For Windows and Linux, it's typically 'MouseWheel' with a capital W
        canvas.bind_all("<MouseWheel>", _on_mousewheel) 
        canvas.bind_all("<Shift-MouseWheel>", _on_shift_mousewheel)

    scrollable_frame = ttk.Frame(canvas)
    
    # Store the window ID to be able to modify it later
    canvas_window_id = canvas.create_window((0, 0), window=scrollable_frame, anchor="nw",
                                            width=canvas.winfo_width()) 

    def _on_canvas_configure(event):
        # Update the width of the window created in the canvas to match the canvas's current width
        canvas.itemconfig(canvas_window_id, width=event.width)
        # Update the scrollregion to encompass the scrolled frame's content
        canvas.configure(scrollregion=canvas.bbox("all"))

    canvas.bind("<Configure>", _on_canvas_configure)
    # This bind is also important: when content size in scrollable_frame changes, update scrollregion
    scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))


    main_frame = ttk.Frame(scrollable_frame, padding=15) # Increased padding
    main_frame.pack(fill="both", expand=True) 
    
    main_frame.grid_columnconfigure(0, weight=1) 

    # --- TLE Section ---
    tle_frame = ttk.LabelFrame(main_frame, text="TLE Parameters", padding=10)
    tle_frame.pack(fill=tk.X, pady=5)
    ttk.Label(tle_frame, text="TLE Line 1").grid(row=0, column=0, sticky="w", padx=5, pady=2)
    tle1_entry = ttk.Entry(tle_frame, width=80) 
    tle1_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
    tle1_entry.insert(0, "1 60543U 24149CD  25156.09113434  .00001223  00000-0  13313-3 0  9994")
    # Bind per impostare lo stato di analisi "scaduta"
    tle1_entry.bind("<KeyRelease>", lambda event: set_analysis_stale())

    ttk.Label(tle_frame, text="TLE Line 2").grid(row=1, column=0, sticky="w", padx=5, pady=2)
    tle2_entry = ttk.Entry(tle_frame, width=80) 
    tle2_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
    tle2_entry.insert(0, "2 60543  97.7181 231.4010 0000622 289.0774  71.0376 14.89798875 43525")
    # Bind per impostare lo stato di analisi "scaduta"
    tle2_entry.bind("<KeyRelease>", lambda event: set_analysis_stale())

    tle_frame.grid_columnconfigure(1, weight=1) 

    # --- Observation Settings Section ---
    obs_frame = ttk.LabelFrame(main_frame, text="Observation Settings", padding=10)
    obs_frame.pack(fill=tk.X, pady=5)
    ttk.Label(obs_frame, text="Date (YYYY-MM-DD)").grid(row=0, column=0, sticky="w", padx=5, pady=2)
    date_entry = ttk.Entry(obs_frame, width=15)
    date_entry.grid(row=0, column=1, sticky="w", padx=5, pady=2)
    date_entry.insert(0, "2025-06-16")
    # Bind per impostare lo stato di analisi "scaduta"
    date_entry.bind("<KeyRelease>", lambda event: set_analysis_stale())

    ttk.Label(obs_frame, text="Ground Station").grid(row=0, column=2, sticky="w", padx=5, pady=2)
    gs_var = tk.StringVar(value="Darmstadt")
    gs_menu = ttk.Combobox(obs_frame, textvariable=gs_var, values=list(GROUND_STATIONS.keys()), state="readonly", width=15)
    gs_menu.grid(row=0, column=3, sticky="w", padx=5, pady=2)
    # Il combobox ora chiama set_analysis_stale() invece di run_analysis()
    gs_menu.bind("<<ComboboxSelected>>", lambda event: set_analysis_stale())
    
    obs_frame.grid_columnconfigure(1, weight=1) 
    obs_frame.grid_columnconfigure(3, weight=1) 

    # --- Parameters container frame for side-by-side parameter boxes ---
    param_container = ttk.Frame(main_frame)
    param_container.pack(fill=tk.X, pady=5, expand=True) 
    
    # Configura le colonne e le righe del param_container per espandersi
    param_container.grid_columnconfigure(0, weight=1)
    param_container.grid_columnconfigure(1, weight=1)
    param_container.grid_columnconfigure(2, weight=1)
    param_container.grid_columnconfigure(3, weight=1)
    param_container.grid_rowconfigure(0, weight=1) # Per la prima riga di frame
    param_container.grid_rowconfigure(1, weight=1) # Per ospitare una seconda riga se i frame si impilano

    # Satellite Parameters frame
    sat_frame = ttk.LabelFrame(param_container, text="Satellite Parameters", padding=10)
    sat_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=5) # Usa grid invece di pack
    ttk.Label(sat_frame, text="EIRP SAT [dBW]").grid(row=0, column=0, sticky="w", padx=5, pady=2)
    eirp_sat_entry = ttk.Entry(sat_frame, width=15)
    eirp_sat_entry.insert(0, "11")
    eirp_sat_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
    ttk.Label(sat_frame, text="Frequency [GHz]").grid(row=1, column=0, sticky="w", padx=5, pady=2)
    freq_entry = ttk.Entry(sat_frame, width=15)
    freq_entry.insert(0, "1.707")
    freq_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
    ttk.Label(sat_frame, text="C/Io [dBHz]").grid(row=2, column=0, sticky="w", padx=5, pady=2)
    CIo_entry = ttk.Entry(sat_frame, width=15)
    CIo_entry.insert(0, "")
    CIo_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
    sat_frame.grid_columnconfigure(1, weight=1)

    # Ground Station Parameters frame
    gs_frame = ttk.LabelFrame(param_container, text="Ground Station Parameters", padding=10)
    gs_frame.grid(row=0, column=1, sticky="nsew", padx=(0, 10), pady=5) # Usa grid
    ttk.Label(gs_frame, text="G/T GS [dB/K]").grid(row=0, column=0, sticky="w", padx=5, pady=2)
    gt_gs_entry = ttk.Entry(gs_frame, width=15)
    gt_gs_entry.insert(0, "8.5")
    gt_gs_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
    ttk.Label(gs_frame, text="Antenna Diameter GS [m]").grid(row=1, column=0, sticky="w", padx=5, pady=2)
    d_gs_entry = ttk.Entry(gs_frame, width=15)
    d_gs_entry.insert(0, "3.7")
    d_gs_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
    gs_frame.grid_columnconfigure(1, weight=1)

    # Atmospheric Attenuations frame
    atm_frame = ttk.LabelFrame(param_container, text="Atmospheric Attenuations", padding=10)
    atm_frame.grid(row=0, column=2, sticky="nsew", padx=(0, 10), pady=5) # Usa grid
    ttk.Label(atm_frame, text="Link Availability [%]").grid(row=0, column=0, sticky="w", padx=5, pady=2)
    LA_entry = ttk.Entry(atm_frame, width=15)
    LA_entry.insert(0, "99")
    LA_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
    ttk.Label(atm_frame, text="R001 [mm/h]").grid(row=1, column=0, sticky="w", padx=5, pady=2)
    r001_entry = ttk.Entry(atm_frame, width=15)
    r001_entry.insert(0, "12.5")
    r001_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
    ttk.Label(atm_frame, text="Other Attenuations [dB]").grid(row=2, column=0, sticky="w", padx=5, pady=2)
    other_att_entry = ttk.Entry(atm_frame, width=15)
    other_att_entry.insert(0, "0.0")
    other_att_entry.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
    atm_label_var = tk.StringVar(value="Atmospheric Att (dB) @ 5° El: N/A")
    ttk.Label(atm_frame, textvariable=atm_label_var).grid(row=3, column=0, columnspan=2, sticky="w", pady=(10,0), padx=5)
    atm_frame.grid_columnconfigure(1, weight=1)

    # Baseband Parameters frame
    baseband_frame = ttk.LabelFrame(param_container, text="Baseband Parameters", padding=10)
    baseband_frame.grid(row=0, column=3, sticky="nsew", pady=5) # Usa grid (niente padx a destra per l'ultimo)
    ttk.Label(baseband_frame, text="Bit Rate [Mbps]").grid(row=0, column=0, sticky="w", padx=5, pady=2)
    bitrate_entry = ttk.Entry(baseband_frame, width=15)
    bitrate_entry.insert(0, "3.57")
    bitrate_entry.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
    ttk.Label(baseband_frame, text="Roll-off Factor").grid(row=0, column=2, sticky="w", padx=5, pady=2)
    rolloff_entry = ttk.Entry(baseband_frame, width=15)
    rolloff_entry.insert(0, "0.45")
    rolloff_entry.grid(row=0, column=3, sticky="ew", padx=5, pady=2)
    ttk.Label(baseband_frame, text="Demodulator Loss [dB]").grid(row=1, column=0, sticky="w", padx=5, pady=2)
    demod_loss_entry = ttk.Entry(baseband_frame, width=15)
    demod_loss_entry.insert(0, "1.5")
    demod_loss_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
    ttk.Label(baseband_frame, text="Overhead (Conv. + RS)").grid(row=1, column=2, sticky="w", padx=5, pady=2)
    overhead_entry = ttk.Entry(baseband_frame, width=15)
    overhead_entry.insert(0, "2.29")
    overhead_entry.grid(row=1, column=3, sticky="ew", padx=5, pady=2)

    info_bitrate_var = tk.StringVar(value="Info Bit Rate [Mbps]: N/A")
    channel_bw_var = tk.StringVar(value="Channel BW [MHz] (QPSK): N/A")
    ttk.Label(baseband_frame, textvariable=info_bitrate_var).grid(row=2, column=0, columnspan=2, sticky="w", pady=(5,0), padx=5)
    ttk.Label(baseband_frame, textvariable=channel_bw_var).grid(row=2, column=2, columnspan=2, sticky="w", padx=5)
    baseband_frame.grid_columnconfigure(1, weight=1)
    baseband_frame.grid_columnconfigure(3, weight=1)

    # Bind entries to update derived parameters (these do not trigger analysis_needs_refresh)
    bitrate_entry.bind("<KeyRelease>", update_link_budget_derived)
    rolloff_entry.bind("<KeyRelease>", update_link_budget_derived)
    overhead_entry.bind("<KeyRelease>", update_link_budget_derived)
    update_link_budget_derived() # Call once to set initial values

    # --- Buttons frame ---
    btn_frame = ttk.Frame(main_frame)
    btn_frame.pack(fill=tk.X, pady=10)
    
    # Assegna il pulsante a una variabile globale e imposta lo stile iniziale a rosso
    start_refresh_button = ttk.Button(btn_frame, text="Start/Refresh Analysis", command=run_analysis, style="Red.TButton")
    start_refresh_button.pack(side=tk.LEFT, padx=5)
    
    # Riferimento globale al pulsante di ricalcolo
    recalc_button = ttk.Button(btn_frame, text="Recalculate Link Budget", command=recalculate_link_budget, state='disabled')
    recalc_button.pack(side=tk.LEFT, padx=5)
    ttk.Button(btn_frame, text="Show Antenna Gain", command=show_antenna_pattern).pack(side=tk.LEFT, padx=5)
    ttk.Button(btn_frame, text="Exit", command=exit_app).pack(side=tk.RIGHT, padx=5)

    # --- Contact List frame ---
    contact_frame = ttk.LabelFrame(main_frame, text="Contact Windows (UTC Time)", padding=10)
    contact_frame.pack(fill=tk.X, pady=5)
    contact_listbox = tk.Listbox(contact_frame, height=6, exportselection=False)
    contact_listbox.pack(fill=tk.X, expand=True)
    contact_listbox.bind("<<ListboxSelect>>", on_contact_select)

    # --- Plot frame ---
    plot_frame = ttk.Frame(main_frame)
    plot_frame.pack(fill=tk.BOTH, expand=True, pady=5)

    # --- Table frame ---
    table_frame = ttk.Frame(main_frame)
    table_frame.pack(fill=tk.BOTH, expand=True, pady=5)

    root.mainloop()

if __name__ == "__main__":
    setup_gui()
